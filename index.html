<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Merry Christmas</title>
        
        <link href="https://fonts.googleapis.com/css?family=Chicle&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=JetBrains+Mono&display=swap" rel="stylesheet">

        
        <style>
			body{
				margin: 0;
				overflow: hidden;
				cursor: auto;
			}
			.overlay-title{
				font-family: 'Chicle', cursive;
				font-size: 44px;
				font-weight: 700;
				letter-spacing: 2px;
				margin-bottom: 30px;
				background: linear-gradient(90deg, #f0eacd, #f7d577, #f7f3dc);
				background-size: 200% 100%;
				-webkit-background-clip: text;
				background-clip: text;
				-webkit-text-fill-color: transparent;
				-webkit-text-stroke: 1px rgba(0,0,0,0.15);
				text-shadow: 0 0 8px rgba(255,255,255,0.6), 0 0 18px rgba(255,215,0,0.35);
				animation: shimmer 4s linear infinite, glow 2.8s ease-in-out infinite;
			}

			@keyframes shimmer{
				0%{ background-position: 0% 50%; }
				100%{ background-position: 200% 50%; }
			}

			@keyframes glow{
				0%,100%{ text-shadow: 0 0 6px rgba(255,255,255,0.5), 0 0 14px rgba(255,215,0,0.28); }
				50%{ text-shadow: 0 0 12px rgba(255,255,255,0.85), 0 0 26px rgba(255,215,0,0.5); }
			}
		.modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:20; overflow:auto; padding:12px 0 14px; }
		.modal-backdrop{ position:absolute; inset:0; background:transparent; pointer-events:auto; }
		.modal-card{
			position:relative;
			width:90%; max-width:560px; /* portrait, tighter border */
			background: linear-gradient(180deg, #ffffff, #fffdf7);
			border-radius:8px;
			border: 2px solid #ffffff;
			box-shadow: 0 12px 36px rgba(0,0,0,0.3), 0 0 0 2px rgba(255,255,255,0.20) inset, 0 0 10px rgba(255,255,255,0.06);
			overflow:hidden;
			animation: borderPulseWhite 3s ease-in-out infinite;
		}
		@keyframes borderPulseWhite{
			0%{
				border-color: #ffffff;
				box-shadow: 0 12px 36px rgba(0,0,0,0.3), 0 0 0 2px rgba(255,255,255,0.20) inset, 0 0 10px rgba(255,255,255,0.06);
			}
			50%{
				border-color: #f3f3f3;
				box-shadow: 0 12px 36px rgba(0,0,0,0.3), 0 0 0 3px rgba(255,255,255,0.26) inset, 0 0 16px rgba(255,255,255,0.10);
			}
			100%{
				border-color: #ffffff;
				box-shadow: 0 12px 36px rgba(0,0,0,0.3), 0 0 0 2px rgba(255,255,255,0.20) inset, 0 0 10px rgba(255,255,255,0.06);
			}
		}
		.modal-header{
			display:none;
		}
		#giftTitle{ display:none; }
		.modal-close{ display:none; }
		.modal-body{ width:90%; margin:0 auto; padding:10px 0 12px; color:#333; max-height:none; overflow-y:visible; display:flex; flex-direction:column; gap:10px; }
		.modal-image{ display:block; width:100%; height:auto; max-height:68vh; margin:0 auto; object-fit:cover; border-radius:10px; border:2px solid rgba(255,255,255,0.85); box-shadow:0 6px 16px rgba(0,0,0,0.18); }

		.modal-image.loading{
			background: linear-gradient(90deg, #f3f3f3 25%, #ecebeb 37%, #f3f3f3 63%);
			background-size: 400% 100%;
			animation: shimmerImg 1.2s ease-in-out infinite;
			min-height: 260px;
		}
		@media (max-width: 480px){
			.modal-body{ width:94%; }
			.modal-image{ width:100%; max-height:65vh; }
		}
		@keyframes shimmerImg{
			0%{ background-position: 100% 0; }
			100%{ background-position: 0 0; }
		}
		.modal-text{ margin-top:0; font-size:18px; line-height:1.9; white-space:pre-wrap; font-family: 'JetBrains Mono', monospace; }
		.letter-box{ background:#f5f4f3; border:1px solid #ecebe6; border-radius:8px; padding:10px 10px; box-shadow:0 2px 10px rgba(0,0,0,0.06) inset; }

		</style>
    </head>
    <body>
	<canvas id = "canvas"></canvas>
	<!-- // thay nhạc -->
	<audio id="bgMusic" src="nhac.mp3" preload="auto"></audio>

	<div id="giftModal" class="modal">
		<div id="giftBackdrop" class="modal-backdrop"></div>
		<div class="modal-card">
			<div class="modal-header">
				<div id="giftTitle">Merry Gift</div>
				<button id="giftClose" class="modal-close" aria-label="Close">×</button>
			</div>
			<div class="modal-body">
				<img id="giftImage" class="modal-image" alt="Gift image" />
				<div id="giftText" class="modal-text letter-box"></div>
			</div>
		</div>
	</div>

	<div id="countdownOverlay" style="position:fixed;inset:0;background: transparent;display:flex;align-items:center;justify-content:center;z-index:10;">
		<div style="width:90%;max-width:900px;text-align:center;color:#fff;padding:50px 24px 140px;position:relative;overflow:hidden;border-radius:10px;">
			<div class="overlay-title">❄ Merry Christmas ❄</div>
			<div style="display:flex;justify-content:center;gap:18px;flex-wrap:wrap;">
				<div class="time-box" style="background:#fff;color:#c73a4a;width:130px;padding:18px 12px;border-radius:8px;">
					<div class="time" id="cd-hours" style="font-size:42px;font-weight:bold;">23</div>
					<div class="label" style="font-size:14px;margin-top:6px;letter-spacing:1px;color:#c73a4a;">HOURS</div>
				</div>
                
				<div class="time-box" style="background:#fff;color:#c73a4a;width:130px;padding:18px 12px;border-radius:8px;">
					<div class="time" id="cd-minutes" style="font-size:42px;font-weight:bold;">59</div>
					<div class="label" style="font-size:14px;margin-top:6px;letter-spacing:1px;color:#c73a4a;">MINUTES</div>
				</div>

				<div class="time-box" style="background:#fff;color:#c73a4a;width:130px;padding:18px 12px;border-radius:8px;">
					<div class="time" id="cd-seconds" style="font-size:42px;font-weight:bold;">55</div>
					<div class="label" style="font-size:14px;margin-top:6px;letter-spacing:1px;color:#c73a4a;">SECONDS</div>
				</div>
			</div>
		
	</div>
    

<script>
		(() => {
		    let color = 3;
		    let canvas = document.getElementById("canvas")
		    let ctx = canvas.getContext('2d')
			let width = window.innerWidth
			let height = window.innerHeight;
			function resizeCanvas(){
				const dpr = Math.max(1, window.devicePixelRatio || 1);
				width = window.innerWidth;
				height = window.innerHeight;
				canvas.style.width = width + 'px';
				canvas.style.height = height + 'px';
		        canvas.width = Math.floor(width * dpr);
		        canvas.height = Math.floor(height * dpr);
				ctx.setTransform(1,0,0,1,0,0);
				ctx.scale(dpr, dpr);
			}
			resizeCanvas();
			window.addEventListener('resize', resizeCanvas);
			const overlay = document.getElementById('countdownOverlay');
			let countdownActive = true;
			// Cấu hình mặc định: 00:00:00 ngày 25/12
			// Cấu trúc lưu time trong JS
			// mont: 0 -> 11
			// day: 1-> 31
			// year: bình thường
			const TARGET_DEFAULT = {month: 11, day: 23, hour: 23, minute: 59, second: 59 };
			function parseFlexibleDate(str, now){
				if (!str) return null;
				const iso = new Date(str);
				if (!isNaN(iso.getTime())) return iso;
				const m = str.match(/^\s*(\d{1,2})[\/\-](\d{1,2})(?:[\/\-](\d{2,4}))?(?:[ T](\d{1,2})(?::(\d{1,2})(?::(\d{1,2}))?)?)?\s*$/);
				if (m){
					let d = parseInt(m[1],10);
					let mo = parseInt(m[2],10);
					let y = m[3] ? parseInt(m[3],10) : now.getFullYear();
					if (y < 100) y += 2000;
					let hh = m[4] ? parseInt(m[4],10) : 0;
					let mm = m[5] ? parseInt(m[5],10) : 0;
					let ss = m[6] ? parseInt(m[6],10) : 0;
					const t = new Date(y, Math.max(0, mo-1), d, hh, mm, ss, 0);
					return isNaN(t.getTime()) ? null : t;
				}
				return null;
			}
			function computeTargetTime(){
				const now = new Date();
				const qs = new URLSearchParams(location.search);
				const q = qs.get('target');
				let t = parseFlexibleDate(q, now);
				if (!t){
					const year = now.getFullYear();
					t = new Date(year, TARGET_DEFAULT.month, TARGET_DEFAULT.day, TARGET_DEFAULT.hour, TARGET_DEFAULT.minute, TARGET_DEFAULT.second, 0);
				}
				// Nếu thời điểm đã qua, đẩy sang năm sau cho case thiếu năm
				if (now >= t && !q?.match(/\d{4}/)){
					t.setFullYear(t.getFullYear() + 1);
				}
				return t;
			}
			const targetTime = computeTargetTime();
			// const targetTime = new Date(Date.now() + 10 * 1000); // +10 giây


			// Nếu đã qua thời điểm, lưu trạng thái vào localStorage để overlay không hiện lại nữa
			// function isTreeUnlocked(){
			// 	const key = 'treeUnlocked';
			// 	if (localStorage.getItem(key) === '1') return true;
			// 	const now = new Date();
			// 	if (now >= targetTime){
			// 		localStorage.setItem(key, '1');
			// 		return true;
			// 	}
			// 	return false;
			// }
			function getChristmasRange(){
				const now = new Date();
				const year = now.getFullYear();

				const start = new Date(year, 11, 24, 0, 0, 0);   // 24/12 00:00:00
				const end   = new Date(year, 11, 31, 23, 59, 59); // 31/12 23:59:59

				return { start, end };
			}

			const { start: christmasStart, end: christmasEnd } = getChristmasRange();

			function isTreeUnlocked(){
				const now = new Date();
				return now >= christmasStart && now <= christmasEnd;
			}


			const hEl = document.getElementById('cd-hours');
			const mEl = document.getElementById('cd-minutes');
			const sEl = document.getElementById('cd-seconds');
			function tickCountdown(){
				if (!countdownActive) return;
				if (isTreeUnlocked()){
					overlay.style.display = 'none';
					countdownActive = false;
					return;
				}
				const now = new Date();
				// Hiển thị đồng hồ hiện tại
				// hEl.textContent = String(now.getHours()).padStart(2,'0');
				// mEl.textContent = String(now.getMinutes()).padStart(2,'0');
				// sEl.textContent = String(now.getSeconds()).padStart(2,'0');
				
				let diff = christmasStart - now;

				// Tính giờ – phút – giây còn lại
				const totalSeconds = Math.floor(diff / 1000);
				const hours = Math.floor(totalSeconds / 3600);
				const minutes = Math.floor((totalSeconds % 3600) / 60);
				const seconds = totalSeconds % 60;

				hEl.textContent = String(hours).padStart(2, '0');
				mEl.textContent = String(minutes).padStart(2, '0');
				sEl.textContent = String(seconds).padStart(2, '0');
			}
			// cập nhật ngay lần đầu
			tickCountdown();
			const cdTimer = setInterval(() => {
				if (!countdownActive){ clearInterval(cdTimer); return; }
				tickCountdown();
			}, 1000);
		    
			const bgMusic = document.getElementById('bgMusic');
			let musicStarted = false;
			function startMusic(){
				if (musicStarted || !bgMusic) return;
				bgMusic.loop = true;
				bgMusic.volume = 0.5;
				const p = bgMusic.play();
				if (p && typeof p.then === 'function'){
					p.then(()=>{ musicStarted = true; }).catch(()=>{ });
				} else {
					musicStarted = true;
				}
			}
			let mousex = 0,
			mousey = 0;
			let camYaw = 0;
			let camPitch = -0.15;
			let camDist = 590;
			let targetCamDist = 590;
			const minCamDist = 380;
			const maxCamDist = 1300;
			const fov = 700;
			let isDragging = false;
			let lastMouseX = 0, lastMouseY = 0;
			let pinchBase = 0;

			function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

			function project3D(wx, wy, wz){
				const cosy = Math.cos(camYaw), siny = Math.sin(camYaw);
				let x1 = wx * cosy + wz * siny;
				let z1 = -wx * siny + wz * cosy;
				const cosp = Math.cos(camPitch), sinp = Math.sin(camPitch);
				let y2 = wy * cosp - z1 * sinp;
				let z2 = wy * sinp + z1 * cosp;
				const denom = (camDist - z2);
				const scale = fov / (denom <= 1 ? 1 : denom);
				const cx = width/2;
				const cy = height/2 + 120;
				return { x: cx + x1 * scale, y: cy + y2 * scale, scale, depth: z2 };
			}
			window.addEventListener('mousedown', (e)=>{
				isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY;
			});
			window.addEventListener('mouseup', ()=>{ isDragging = false; });
			window.addEventListener('mouseleave', ()=>{ isDragging = false; });
			window.addEventListener('mousemove', (e)=>{
				mousex = e.clientX; mousey = e.clientY;
				if(isDragging){
					const dx = e.clientX - lastMouseX;
					camYaw += dx * 0.004;
					lastMouseX = e.clientX; lastMouseY = e.clientY;
				}
			});
			window.addEventListener('click', startMusic, { once: true });
			window.addEventListener('touchstart', startMusic, { once: true, passive: true });
			window.addEventListener('wheel', (e)=>{
				targetCamDist = clamp(targetCamDist * (1 + Math.sign(e.deltaY) * 0.08), minCamDist, maxCamDist);
			},{passive:true});
			window.addEventListener('touchstart', (e)=>{
				if(e.touches.length===1){
					lastMouseX = e.touches[0].clientX; lastMouseY = e.touches[0].clientY;
				} else if(e.touches.length===2){
					const dx = e.touches[0].clientX - e.touches[1].clientX;
					const dy = e.touches[0].clientY - e.touches[1].clientY;
					pinchBase = Math.hypot(dx, dy);
				}
			},{passive:true});
			window.addEventListener('touchmove', (e)=>{
				if(e.touches.length===1){
					const x = e.touches[0].clientX;
					camYaw += (x - lastMouseX) * 0.004;
					lastMouseX = x; lastMouseY = e.touches[0].clientY;
				} else if(e.touches.length===2){
					const dx = e.touches[0].clientX - e.touches[1].clientX;
					const dy = e.touches[0].clientY - e.touches[1].clientY;
					const d = Math.hypot(dx, dy);
					if(pinchBase>0){
						const ratio = pinchBase / Math.max(1, d);
						targetCamDist = clamp(targetCamDist * ratio, minCamDist, maxCamDist);
					}
					pinchBase = d;
				}
			},{passive:true});
			window.addEventListener('touchend', ()=>{ pinchBase = 0; }, {passive:true});

			// // đặt con trỏ cây thông(XOA DE MAT)
			// setTreeCursor();

		    function dist(a, b, c, d){
               return Math.sqrt((a-c)*(a-c)+(b-d)*(b-d));
            }

		    function lerp(x1, x2, x3) {
		        return (x2 - x1) * x3 + x1;
		    }

		    function random(min, max) {
		        return min + Math.random() * (max - min);
		    }

		    function ellipse(x, y, w, h) {
		        ctx.beginPath();
		        ctx.ellipse(x, y, w / 2, h / 2, 0, 0, 2 * Math.PI);
		        ctx.fill();
		        ctx.closePath();
		    };
		    function drawTreeGlowCone(){
		    	const cx = width/2;
		    	const baseY = height/2 + 295;
		    	const H = 520;
		    	const R = 210;
		    	const layers = 24;
		    	const timePulse = 0.6 + 0.4 * Math.sin(frameCount * 0.03);
		    	const sweep = (frameCount * 2) % H;
		    	ctx.save();
		    	ctx.globalCompositeOperation = 'lighter';
		    	for (let i = 0; i <= layers; i++){
		    		const t = i / layers;
		    		const y = baseY - t * H;
		    		const rx = R * (1 - t * 0.92) + 10;
		    		const ry = rx * 0.32;
		    		const a = 0.035 * (1 - t) * timePulse;
		    		ctx.fillStyle = `rgba(255,245,210,${a})`;
		    		ellipse(cx, y, rx * 2, ry * 2);
		    		const bandY = baseY - sweep;
		    		const dy = Math.abs(bandY - y);
		    		if (dy < 22){
		    			const k = 1 - dy / 22;
		    			ctx.fillStyle = `rgba(255,255,230,${0.06 * k})`;
		    			ellipse(cx, y, rx * 1.4, ry * 1.2);
		    		}
		    	}
		    	ctx.restore();
		    }

		    function hexToRgba(hex, a){
		        const r = parseInt(hex.slice(1,3),16);
		        const g = parseInt(hex.slice(3,5),16);
		        const b = parseInt(hex.slice(5,7),16);
		        return `rgba(${r},${g},${b},${a})`;
		    }
		    function drawGiftIcon(x, y, scale=1){
		        const w = 18*scale, h = 16*scale;
		        ctx.save();
		        ctx.translate(x, y);
		        ctx.fillStyle = '#c73a4a';
		        ctx.fillRect(-w/2, -h/2, w, h);
		        ctx.fillStyle = '#b6303f';
		        ctx.fillRect(-w/2, -h/2-4*scale, w, 6*scale);
		        ctx.fillStyle = '#ffd85a';
		        ctx.fillRect(-2*scale, -h/2-4*scale, 4*scale, h+6*scale);
		        ctx.fillRect(-w/2, -1*scale, w, 2*scale);
		        ctx.restore();
		    }

		    // Tạo con trỏ hình cây thông bằng canvas rồi đặt làm cursor
		    function setTreeCursor(){
		    	try{
		    		const size = 32;
		    		const off = document.createElement('canvas');
		    		off.width = size; off.height = size;
		    		const octx = off.getContext('2d');
		    		octx.clearRect(0,0,size,size);

		    		// ngôi sao nhỏ trên đỉnh
		    		octx.fillStyle = '#FFD700';
		    		octx.beginPath();
		    		octx.arc(16, 6, 3, 0, Math.PI*2);
		    		octx.fill();

		    		// lá cây thông (ba tầng tam giác)
		    		octx.fillStyle = '#2f7e3c';
		    		octx.beginPath();
		    		octx.moveTo(16, 8);
		    		octx.lineTo(26, 18);
		    		octx.lineTo(6, 18);
		    		octx.closePath();
		    		octx.fill();

		    		octx.beginPath();
		    		octx.moveTo(16, 14);
		    		octx.lineTo(28, 24);
		    		octx.lineTo(4, 24);
		    		octx.closePath();
		    		octx.fill();

		    		octx.beginPath();
		    		octx.moveTo(16, 20);
		    		octx.lineTo(30, 30);
		    		octx.lineTo(2, 30);
		    		octx.closePath();
		    		octx.fill();

		    		// thân cây
		    		octx.fillStyle = '#8b5a2b';
		    		octx.fillRect(14, 30, 4, 2);

		    		// bóng đèn trang trí nhỏ
		    		function bulb(x,y,c){
		    			octx.fillStyle = c;
		    			octx.beginPath();
		    			octx.arc(x, y, 1.2, 0, Math.PI*2);
		    			octx.fill();
		    		}
		    		bulb(20,18,'#ff6b6b');
		    		bulb(12,22,'#ffd85a');
		    		bulb(22,26,'#7cc8ff');

		    		const dataUrl = off.toDataURL('image/png');
		    		// hotspot đặt gần đỉnh để dễ click (x=8, y=2)
		    		document.body.style.cursor = 'url('+dataUrl+') 8 2, auto';
		    	} catch(e){
		    		document.body.style.cursor = 'auto';
		    	}
		    }    // TAT TOI DAY

		    let particles = [];
		    let orbitEnergy = 0;
		    let dots = [];
		    class Particle {
		        constructor() {
		            this.x = random(-50, (width + 50))
		            this.y = -50;
		            this.o = random(0.75, 0.85);
		            this.xv = random(-3, -1)
		            this.yv = random(1, 4)
		            this.s = random(1, 3)
		            this.dead = false;
		        }
		        draw() {
					ctx.fillStyle = `rgba(255, 255, 255, ${this.o})`
					ctx.fillRect(this.x, this.y, this.s, this.s)

		        }

		        update() {

		            this.y += this.yv;
		            this.x += this.xv
		            if (this.y >= height-200) {
		                this.o -= 0.01
		            }
		            if (this.y >= height) {
		                this.dead = true;
		            }
		            if (this.x <= 0 - this.s) {

		                this.x = width
		            }

		            this.draw()

		        }
		    }


			class Dot {
			    constructor(y, r, ra, idx, isTrunk = false) {
			        this.y = y;
			        this.r = r;
			        this.ra = Math.max(ra, 0);
			        this.isTrunk = !!isTrunk;
			        this.s = this.isTrunk ? 2.8 : 2.6;
			        this.idx = idx;
			        this.px = 0; this.py = 0; this.pscale = 1; this.depth = 0;
					this.isBulb = !this.isTrunk && (Math.random() < 0.045) && (this.ra > 45) && (this.y < (height/2 + 250));
			        if (this.isBulb){
			            this.bulbColors = ['#ffd36b','#ff6b6b','#7cc8ff','#ff7bf1','#7bf1ff','#ffa07a'];
			            this.bulbColor = this.bulbColors[Math.floor(Math.random()*this.bulbColors.length)];
			            this.bulbPhase = Math.random() * Math.PI * 2;
			            this.bulbSpeed = 0.045 + Math.random() * 0.055;
			        }
			    }
			    draw() {
			        if (this.isTrunk) {
			            ctx.fillStyle = `rgba(139, 90, 43, 1)`;
			            ellipse(this.px, this.py, this.s * this.pscale, this.s * this.pscale);
			            ctx.fillStyle = "rgba(139, 90, 43, 0.06)";
			            ellipse(this.px, this.py, this.s * this.pscale * 6, this.s * this.pscale * 6);
			        } else {
			            ctx.fillStyle = `rgba(34, 85, 34, 1)`;
			            ellipse(this.px, this.py, this.s * this.pscale, this.s * this.pscale);
			            ctx.fillStyle = "rgba(90, 140, 90, 0.06)";
			            ellipse(this.px, this.py, this.s * this.pscale * 6, this.s * this.pscale * 6);
						if (this.isBulb){
							const t = frameCount * this.bulbSpeed + this.bulbPhase;
							const intensity = 0.45 + 0.55 * Math.sin(t);
							const rad = (1.2 + intensity * 1.8) * this.pscale;
							ctx.fillStyle = this.bulbColor;
							ellipse(this.px, this.py, rad, rad);
							ctx.fillStyle = hexToRgba(this.bulbColor, 0.10 + intensity * 0.16);
							ellipse(this.px, this.py, rad * 4.0, rad * 4.0);
						}
			        }
			    }
			    update() {
			        this.r += 0.015;
			        const wx = Math.cos(this.r) * this.ra;
			        const wz = Math.sin(this.r) * this.ra;
			        const wy = (this.y - (height/2 + 120));
			        const p = project3D(wx, wy, wz);
			        this.px = p.x; this.py = p.y; this.pscale = Math.max(0.4, Math.min(2.2, p.scale)); this.depth = p.depth;
			        this.draw();
			    }
			}
		    class OrbitRing {
		        constructor(y, radius, count, speed, tilt) {
		            this.cx = width / 2;
		            this.cy = y;
		            this.radius = radius;
		            this.count = count;
		            this.speed = speed;
		            this.tilt = tilt;
		            this.angle = Math.random() * Math.PI * 2;
		            this.twinkleBase = Math.random() * Math.PI * 2;
		            this.twinkleSpeed = random(0.02, 0.05);
		            this.dots = [];
		            for (let i = 0; i < count; i++) {
		                this.dots.push({
		                    a: (Math.PI * 2 / count) * i,
		                    s: random(1.6, 2.8),
		                    o: random(0.4, 0.9),
		                    jit: random(0.0, 0.8),
		                    tw: random(0.6, 1.2)
		                });
		            }
		            this.cometIndex = Math.floor(Math.random() * this.dots.length);
		        }

		        update() {
		            this.angle += this.speed;

		            ctx.save();
		            ctx.translate(this.cx, this.cy);
		            const dynamicTilt = this.tilt + Math.sin(frameCount * 0.01 + this.twinkleBase) * 0.05;
		            ctx.rotate(dynamicTilt);
		            ctx.save();
		            ctx.globalCompositeOperation = 'lighter';
		            ctx.beginPath();
		            ctx.ellipse(0, 0, this.radius, this.radius * 0.3, 0, 0, Math.PI * 2);
		            const glowAlpha = 0.04 + 0.06 * (Math.sin(this.angle) * 0.5 + 0.5);
		            ctx.fillStyle = `rgba(255, 255, 240, ${glowAlpha})`;
		            ctx.fill();
		            ctx.lineWidth = 1.2;
		            ctx.strokeStyle = `rgba(255, 255, 240, ${glowAlpha * 0.8})`;
		            ctx.stroke();
		            ctx.restore();
		            ctx.save();
		            ctx.globalCompositeOperation = 'lighter';
		            ctx.lineWidth = 10;
		            ctx.shadowColor = 'rgba(255,255,235,0.25)';
		            ctx.shadowBlur = 16;
		            ctx.strokeStyle = 'rgba(255,240,210,0.18)';
		            ctx.beginPath();
		            ctx.ellipse(0, 0, this.radius, this.radius * 0.3, 0, 0, Math.PI * 2);
		            ctx.stroke();
		            // bright core line
		            ctx.lineWidth = 2.8;
		            ctx.shadowColor = 'rgba(255,255,255,0.35)';
		            ctx.shadowBlur = 8;
		            ctx.strokeStyle = 'rgba(255,255,255,0.35)';
		            ctx.beginPath();
		            ctx.ellipse(0, 0, this.radius, this.radius * 0.3, 0, 0, Math.PI * 2);
		            ctx.stroke();
		            ctx.restore();
		            const sweepAngle = (frameCount * 0.02 + this.twinkleBase) % (Math.PI * 2);
		            const arcWidth = 0.55;
		            ctx.save();
		            ctx.globalCompositeOperation = 'lighter';
		            ctx.lineCap = 'round';
		            ctx.lineWidth = 8;
		            ctx.shadowColor = 'rgba(255,255,235,0.45)';
		            ctx.shadowBlur = 18;
		            ctx.strokeStyle = 'rgba(255,250,220,0.22)';
		            ctx.beginPath();
		            ctx.ellipse(0, 0, this.radius, this.radius * 0.3, 0, sweepAngle - arcWidth, sweepAngle + arcWidth);
		            ctx.stroke();
		            ctx.lineWidth = 3.2;
		            ctx.shadowColor = 'rgba(255,255,255,0.55)';
		            ctx.shadowBlur = 12;
		            ctx.strokeStyle = 'rgba(255,255,255,0.38)';
		            ctx.beginPath();
		            ctx.ellipse(0, 0, this.radius, this.radius * 0.3, 0, sweepAngle - arcWidth * 0.6, sweepAngle + arcWidth * 0.6);
		            ctx.stroke();
		            ctx.restore();
		            orbitEnergy = Math.sin(this.angle) * 0.5 + 0.5;
		            if (Math.random() < 0.008) {
		                const x = Math.cos(sweepAngle) * this.radius;
		                const y = Math.sin(sweepAngle) * this.radius * 0.3;
		                const wx = this.cx + x;
		                const wy = this.cy + y;
		                lightRays.push(new LightRay(wx, wy));
		            }

		            ctx.restore();
		        }
		    }
		    class LightRay {
		        constructor(x, y) {
		            this.x = x;
		            this.y = y;
		            this.len = random(20, 60);
		            this.life = 1;
		            this.speed = random(0.5, 1.5);
		            this.spread = random(-0.3, 0.3);
		        }

		        update() {
		            this.y -= this.speed * 2;
		            this.x += this.spread;
		            this.life -= 0.02;

		            ctx.strokeStyle = `rgba(255,255,240,${this.life})`;
		            ctx.lineWidth = 1;

		            ctx.beginPath();
		            ctx.moveTo(this.x, this.y);
		            ctx.lineTo(this.x, this.y + this.len);
		            ctx.stroke();
		        }
		    }
			let dotIndexCounter = 0;
			for (let i = 0; i < 250; i++) {
			    for (let j = 0; j < 10; j++) {
			        dots.push(new Dot((height-370)/2 + 320 + random(0, 2) - i * 1.5, random(0, Math.PI * 2), 120 - i * 0.485, dotIndexCounter++))
			    }
			    dots.push(new Dot((height-370)/2 + 370 - i / 3, random(0, Math.PI * 2), 30, dotIndexCounter++, true))
			}




			let frameCount = 0;
		    let orbits = [];
		    let lightRays = [];
		    const fallingGifts = [];
		    const MAX_FALLING_GIFTS = 36;
		    const GIFT_SPAWN_EVERY_FRAMES = 10;
		    const MAX_PARTICLES = 600;
			const MAX_SNOW = 180;
			const snowflakes = [];
			const MAX_SNOW_ICONS = 60;
			const snowIcons = [];
			const STAR_COLOR = '#FFD700';

			// Ảnh và lời ở thư thay ở đây
			const contentItems = [
				{ img: 'img/anh.jpg', text: 'Chúc bạn một mùa Giáng Sinh an lành, tràn đầy yêu thương.Hãy tận hưởng từng khoảnh khắc nhỏ bé thật ấm áp.' },
				{ img: 'img/anh1.jpg', text: 'Mong những ngày này luôn rực rỡ và ấm áp.Gửi đến bạn thật nhiều niềm vui và tiếng cười.' },
				{ img: 'img/anh2.jpg', text: 'Chúc Châu một mùa bình an và yêu thương.Cảm ơn vì cậu luôn hiện diện.' },
				{ img: 'img/anh3.jpg', text: 'Chúc Châu thành công trong học tập, ngày một xinh đẹp, hạnh phúc và luôn tươi cười!!' },
				// { img: 'img/anh4.jpg', text: 'Hãy thật ấm áp, thật rạng rỡ, và luôn mỉm cười.Bạn xứng đáng nhận những điều tốt đẹp.' },
				// { img: 'img/anh5.jpg', text: 'Chúc bạn một mùa bình an và yêu thương.Cảm ơn vì bạn luôn hiện diện.' },
				// { img: 'img/anh6.jpg', text: 'Tuyết rơi, ánh đèn lấp lánh.Chúc bạn tận hưởng bầu không khí lễ hội!' },
				// { img: 'img/anh7.jpg', text: 'Chúc bạn một mùa bình an và yêu thương.Cảm ơn vì bạn luôn hiện diện.' },
				// { img: 'img/anh8.jpg', text: 'Chúc bạn một mùa bình an và yêu thương.Cảm ơn vì bạn luôn hiện diện.' }
			];
			const modal = document.getElementById('giftModal');
			const modalTitle = document.getElementById('giftTitle');
			const modalImg = document.getElementById('giftImage');
			const modalText = document.getElementById('giftText');
			const modalClose = document.getElementById('giftClose');
			const modalBackdrop = document.getElementById('giftBackdrop');
			const imageCache = new Map();
			function preloadImages(){
				for(const item of contentItems){
					if(!item || !item.img) continue;
					if(imageCache.has(item.img)) continue;
					const im = new Image();
					im.src = item.img;
					imageCache.set(item.img, im);
				}
			}
			preloadImages();
			let typeTimer = null;
			const TYPE_SPEED = 35;
			function startTypewriter(text){
				if (typeTimer) { clearTimeout(typeTimer); typeTimer = null; }
				modalText.textContent = '';
				let i = 0;
				function step(){
					if (i < text.length){
						modalText.textContent += text[i];
						let delay = TYPE_SPEED;
						if (text[i] === '\n') delay += 220;
						i++;
						typeTimer = setTimeout(step, delay);
					} else {
						typeTimer = null;
					}
				}
				step();
			}

			function openGiftModal(info){
				modalTitle.textContent = '';
				startTypewriter(info.text || '');
				modalImg.classList.add('loading');
				const cached = (info.img && imageCache.get(info.img)) || null;
				const handleLoad = () => {
					modalImg.classList.remove('loading');
					modalImg.removeEventListener('load', handleLoad);
				};
				modalImg.addEventListener('load', handleLoad);
				modalImg.src = cached && cached.complete ? cached.src : (info.img || '');
				modal.style.display = 'flex';
			}
			function closeGiftModal(){
				if (typeTimer) { clearTimeout(typeTimer); typeTimer = null; }
				modal.style.display = 'none';
			}
			modalClose.addEventListener('click', closeGiftModal);
			modalBackdrop.addEventListener('click', closeGiftModal);
			window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeGiftModal(); });

			canvas.addEventListener('click', (e)=>{
				if (countdownActive) return;
				const rect = canvas.getBoundingClientRect();
				const x = e.clientX - rect.left;
				const y = e.clientY - rect.top;
				for (let i = 0; i < fallingGifts.length; i++){
					const g = fallingGifts[i];
					const r = 18 * g.size;
					const dx = x - g.x, dy = y - g.y;
					if (dx*dx + dy*dy <= r*r){
						const info = (typeof g.contentIndex === 'number') ? contentItems[g.contentIndex] : null;
						if (info) openGiftModal(info);
						g.dead = true;
						break;
					}
				}
			});
			function makeSnowGlyph(size){
				const off = document.createElement('canvas');
				off.width = size * 2; off.height = size * 2;
				const octx = off.getContext('2d');
				octx.clearRect(0,0,off.width,off.height);
				octx.fillStyle = 'white';
				octx.font = `${size}px JetBrains Mono, Chicle, system-ui, sans-serif`;
				octx.textAlign = 'center';
				octx.textBaseline = 'middle';
				octx.globalAlpha = 0.9;
				octx.fillText('❄', off.width/2, off.height/2);
				return off;
			}

			class SnowIcon {
				constructor(){
					this.reset(true);
				}
				reset(randomY=false){
					this.x = random(-50, width + 50);
					this.y = randomY ? random(-height, height) : -30;
					this.size = random(10, 22);
					this.speedY = random(0.4, 1.4);
					this.phase = random(0, Math.PI * 2);
					this.speedX = random(0.15, 0.5);
					this.spin = random(-0.01, 0.01);
					this.angle = random(0, Math.PI*2);
					this.sprite = makeSnowGlyph(Math.floor(this.size));
				}
				update(){
					this.phase += 0.02 * this.speedX;
					this.x += Math.cos(this.phase) * 0.7;
					this.y += this.speedY;
					this.angle += this.spin;
					if(this.y - this.size > height){
						this.reset(false);
					}
				}
				draw(){
					ctx.save();
					ctx.translate(this.x, this.y);
					ctx.rotate(this.angle);
					ctx.globalAlpha = 0.95;
					ctx.drawImage(this.sprite, -this.sprite.width/2, -this.sprite.height/2);
					ctx.restore();
				}
			}

			class Snowflake {
				constructor(){
					this.reset(true);
				}
				reset(randomY=false){
					this.x = random(-50, width + 50);
					this.y = randomY ? random(-height, height) : -20;
					this.r = random(1.0, 3.0);
					this.speedY = random(0.5, 1.8);
					this.phase = random(0, Math.PI * 2);
					this.amp = random(5, 18);
					this.speedX = random(0.2, 0.6);
					this.opacity = random(0.6, 0.95);
				}
				update(){
					this.phase += 0.02 * this.speedX;
					this.x += Math.cos(this.phase) * 0.6;
					this.y += this.speedY;
					if(this.y - this.r > height){
						this.reset(false);
					}
				}
				draw(){
					ctx.fillStyle = `rgba(255,255,255,${this.opacity})`;
					ctx.beginPath();
					ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
					ctx.fill();
				}
			}

			class FallingGift{
				constructor(){
					this.x = random(-50, width + 50);
					this.y = -30;
					this.vy = random(1.0, 2.2);
					this.phase = random(0, Math.PI*2);
					this.vxPhase = random(0.15, 0.5);
					this.size = random(1.6, 2.4);
					this.angle = random(-0.2, 0.2);
					this.spin = random(-0.02, 0.02);
					this.dead = false;
					this.contentIndex = contentItems.length ? Math.floor(Math.random() * contentItems.length) : null;
				}
				update(){
					this.phase += 0.02 * this.vxPhase;
					this.x += Math.cos(this.phase) * 0.7;
					this.y += this.vy;
					this.angle += this.spin;
					if (this.y > height + 40) this.dead = true;
				}
				draw(){
					ctx.save();
					ctx.translate(this.x, this.y);
					ctx.rotate(this.angle);
					drawGiftIcon(0, 0, this.size);
					ctx.restore();
				}
			}

			function findTreeTop(){
				let top = null;
				for (let i = 0; i < dots.length; i++){
					const d = dots[i];
					if (d.ra < 40){
						if (!top || d.y < top.y){ top = d; }
					}
				}
				return top;
			}

			function drawStar(cx, cy, outerR, innerR, points, color){
				ctx.save();
				ctx.translate(cx, cy);
				ctx.beginPath();
				for(let i=0;i<points*2;i++){
					const angle = (Math.PI/points) * i - Math.PI/2;
					const r = (i % 2 === 0) ? outerR : innerR;
					const x = Math.cos(angle) * r;
					const y = Math.sin(angle) * r;
					if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
				}
				ctx.closePath();
				const hex = color;
				const r = parseInt(hex.slice(1,3),16);
				const g = parseInt(hex.slice(3,5),16);
				const b = parseInt(hex.slice(5,7),16);
				ctx.fillStyle = `rgba(${r},${g},${b},0.95)`;
				ctx.fill();
				ctx.restore();
				ctx.fillStyle = `rgba(${r},${g},${b},0.08)`;
				ellipse(cx, cy, outerR*6, outerR*6);
			}
			function draw() {
		        ctx.fillStyle = "black"
		        ctx.fillRect(0, 0, width, height)
		        while (snowflakes.length < MAX_SNOW) {
		            snowflakes.push(new Snowflake());
		        }

		        if (particles.length < MAX_PARTICLES) {
		            const spawn = Math.min(6, MAX_PARTICLES - particles.length);
		            for (let i = 0; i < spawn; i++) {
		                particles.push(new Particle())
		            }
		        }
		        ctx.save();
		        for (let i = particles.length - 1; i >= 0; i--) {
		            const p = particles[i];
		            p.update();
		            if (p.dead) {
		                particles.splice(i, 1);
		            }
		        }

				while (snowIcons.length < MAX_SNOW_ICONS){
					snowIcons.push(new SnowIcon());
				}

		        for (let i = 0; i < snowflakes.length; i++){
		            snowflakes[i].update();
		            snowflakes[i].draw();
		        }
				for (let i = 0; i < snowIcons.length; i++){
					snowIcons[i].update();
					snowIcons[i].draw();
				}
				if (!countdownActive){
					if (fallingGifts.length < MAX_FALLING_GIFTS && (frameCount % GIFT_SPAWN_EVERY_FRAMES === 0)){
						fallingGifts.push(new FallingGift());
					}
					for (let i = fallingGifts.length - 1; i >= 0; i--){
						const g = fallingGifts[i];
						g.update();
						g.draw();
						if (g.dead) fallingGifts.splice(i,1);
					}
				}

				if (!countdownActive) {
					const topDot = findTreeTop();
					if (topDot){
						const sx = topDot.px;
						const sy = topDot.py - 14 * Math.max(0.8, topDot.pscale);
						drawStar(sx, sy, 14 * Math.max(0.7, topDot.pscale), 7 * Math.max(0.5, topDot.pscale*0.6), 5, STAR_COLOR);
					}
				}

		        ctx.restore();
		        
          ctx.save();
          
				if (!countdownActive) {
					camDist += (targetCamDist - camDist) * 0.08;
					for (let dot of dots) {
						dot.update();
					}
				}
		  ctx.restore();
			ctx.save();
			if (!countdownActive){
				drawTreeGlowCone();
			}
			ctx.restore();

		        frameCount++;
		        if (frameCount % 12 === 0) {
		            dots.sort((a, b) => a.depth - b.depth);
		        }

				if (!countdownActive) {
					for (let o of orbits) o.update();
					for (let i = lightRays.length - 1; i >= 0; i--) {
						lightRays[i].update();
						if (lightRays[i].life <= 0) {
							lightRays.splice(i, 1);
						}
					}
				}

		    }

		    function loop(){
		        draw();
		        window.requestAnimationFrame(loop);
		    }
		    window.requestAnimationFrame(loop);
			orbits.push(
			    new OrbitRing(height/2 + 260, 120, 80, 0.01, 0.3),
			    new OrbitRing(height/2 + 280, 160, 100, -0.008, -0.2),
			    new OrbitRing(height/2 + 300, 200, 120, 0.006, 0.15)
			);

		})();
        </script>
        

    </body>
</html>
